"""Purge and rebuild qb_timeline and QNR associations on affected patients

Revision ID: c19bff0f70ab
Revises: b3c0554cde0e
Create Date: 2020-12-10 15:07:28.770271

"""
from alembic import op
from flask import current_app
from sqlalchemy.orm import sessionmaker

from portal.dict_tools import dict_compare
from portal.models.user import User
from portal.models.qb_timeline import QBT, update_users_QBT
from portal.models.questionnaire_bank import QuestionnaireBank
from portal.models.questionnaire_response import QuestionnaireResponse

# revision identifiers, used by Alembic.
revision = 'c19bff0f70ab'
down_revision = 'b3c0554cde0e'
Session = sessionmaker()


def capture_qnr_state(session, patient, name_map):
    qnrs = session.query(QuestionnaireResponse).filter(
        QuestionnaireResponse.subject_id == patient.id).with_entities(
        QuestionnaireResponse.id,
        QuestionnaireResponse.questionnaire_bank_id,
        QuestionnaireResponse.qb_iteration)

    return {
        f"qnr {qnr.id}":
            [name_map[qnr.questionnaire_bank_id], qnr.qb_iteration] for
        qnr in qnrs}


def capture_tl_state(session, patient, name_map):
    tl = session.query(QBT).filter(
        QBT.user_id == patient.id).with_entities(
        QBT.at,
        QBT.qb_id,
        QBT.status,
        QBT.qb_iteration).order_by(
        QBT.at)

    return {
        f"{t.at} {t.status}": [name_map[t.qb_id], t.qb_iteration] for
        t in tl}


def affected_patients_list():
    """Hand curated list of patient IDs needing updates

    List can be generated by processing all patients off-line and using
    output from this very migration to generate the affected list of
    patient IDs.

    Not desirable to just run on production over all patients as it
    takes a considerable amount of time, and generates lots of audit
    logging noise.

    """
    if not (
            current_app.config.get('SYSTEM_TYPE') == 'production' and
            current_app.config.get('GIL') is None):
        return []

    patients = (
        37, 38, 86, 114, 122, 164, 248, 281, 285, 289, 317, 328, 348, 403,
        433, 444, 452, 455, 460, 465, 466, 478, 481, 502, 503, 518, 523, 545,
        563, 565, 568, 570, 574, 583, 594, 596, 611, 636, 641, 645, 656, 662,
        674, 685, 698, 700, 728, 743, 744, 767, 780, 801, 813, 819, 834, 854,
        860, 861, 869, 886, 963, 968, 982, 984, 985, 991, 1031, 1062, 1067,
        1073, 1087, 1098, 1100, 1113, 1123, 1128, 1129, 1149, 1150, 1161,
        1162, 1166, 1170, 1172, 1177, 1179, 1188, 1205, 1207, 1220, 1222,
        1235, 1239, 1245, 1249, 1273, 1283, 1312, 1315, 1352, 1368, 1389,
        1390, 1392, 1415, 1417, 1424, 1429, 1431, 1432, 1433, 1442, 1448,
        1461, 1471, 1492, 1493, 1516, 1524, 1545, 1546, 1548, 1551, 1565,
        1571, 1581, 1582, 1584, 1587, 1605, 1626, 1630, 1634, 1636, 1650,
        1707, 1738, 1756, 1771, 1813, 1819, 1824, 1831, 1850, 1853, 1862,
        1875, 1891, 1900, 1901, 1907, 1919, 1927, 1932, 1942, 1943, 1947,
        1948, 1968, 1986, 1995, 2012, 2025, 2027, 2040, 2053, 2119, 2132,
        2150, 2152, 2153, 2170, 2175, 2210, 2245, 2261, 2290, 2295, 2303,
        2306, 2313, 2320, 2330, 2331, 2353, 2409, 2433, 2444, 2453, 2483,
        2498, 2505, 2508, 2528, 2617, 2618, 2621, 2630, 2637, 2638, 2652,
        2679, 2683, 2686, 2690, 2715, 2719, 2720, 2722, 2723, 2724, 2761,
        2768, 2771, 2791, 2801, 2839, 2841, 2847, 2851, 2856, 2861, 2862,
        2871, 2881, 2888, 2899, 2900, 2901, 2904, 2914, 2927, 2949, 2954,
        2958, 2964, 2982, 2991, 2992, 3005, 3010, 3014, 3015, 3022, 3023,
        3024, 3039, 3049, 3059, 3065, 3067, 3068, 3073, 3077, 3109, 3121,
        3122, 3123, 3131, 3140, 3148, 3166, 3173, 3174, 3182, 3185, 3189,
        3196, 3214, 3216, 3217, 3222, 3228, 3229, 3236, 3252, 3257, 3258,
        3261, 3262, 3271, 3279, 3280, 3281, 3285, 3297, 3328, 3337, 3345,
        3360, 3375, 3377, 3378, 3384, 3398, 3419, 3425, 3426, 3427, 3442,
        3443, 3455, 3458, 3466, 3473, 3487, 3493, 3494, 3506, 3508, 3511,
        3513, 3517, 3519, 3521, 3522, 3532, 3536, 3539, 3544, 3576, 3591,
        3595, 3601, 3617, 3624, 3629, 3640, 3645, 3646, 3657, 3668, 3672,
        3687, 3688, 3700, 3706, 3707, 3713, 3730, 3743, 3758, 3762, 3789,
        3790, 3801, 3823, 3831, 3851, 3852, 3874, 3883, 3885, 3900, 3908,
        3909, 3912, 3914, 3922, 3930)
    return patients


def upgrade():
    conn = op.get_bind()
    session = Session(bind=op.get_bind())
    admin_id = conn.execute(
        "SELECT id FROM users WHERE email='__system__'").fetchone()[0]

    qb_name_map = {qb.id: qb.name for qb in QuestionnaireBank.query.all()}
    qb_name_map[None] = "None"
    # Used to locate all affected patients
    # patients = session.query(QBT).distinct(QBT.user_id).with_entities(
    #    QBT.user_id)
    patients = affected_patients_list()

    for p_id in patients:
        patient = User.query.get(p_id)
        if patient.deleted_id:
            continue
        if patient.has_role("test"):
            continue

        # capture before and after state to identify necessary updates

        before_qnrs = capture_qnr_state(session, patient, qb_name_map)
        before_timeline = capture_tl_state(session, patient, qb_name_map)
        QuestionnaireResponse.purge_qb_relationship(
            subject_id=patient.id,
            acting_user_id=admin_id
        )
        update_users_QBT(patient.id, True)
        after_qnrs = capture_qnr_state(session, patient, qb_name_map)
        after_timeline = capture_tl_state(session, patient, qb_name_map)

        # Compare results
        added_q, removed_q, modified_q, same = dict_compare(
            after_qnrs, before_qnrs)
        assert not added_q
        assert not removed_q

        added_t, removed_t, modified_t, same = dict_compare(
            after_timeline, before_timeline)

        if any((added_t, removed_t, modified_t, modified_q)):
            print(f"\nPatient {patient.id}:")
        if modified_q:
            print("\tModified QNRs (old, new)")
            for mod in sorted(modified_q):
                print(f"\t\t{mod} {modified_q[mod][1]} ==>"
                      f" {modified_q[mod][0]}")
        if added_t:
            print("\tAdditional timeline rows:")
            for item in sorted(added_t):
                print(f"\t\t{item} {after_timeline[item]}")
        if removed_t:
            print("\tRemoved timeline rows:")
            for item in sorted(removed_t):
                print(f"\t\t{item} {before_timeline[item]}")
        if modified_t:
            print(f"\tModified timeline rows: (old, new)")
            for item in sorted(modified_t):
                print(f"\t\t{item}")
                print(f"\t\t\t{modified_t[item][1]} ==> {modified_t[item][0]}")

        print('.', end='', flush=True)


def downgrade():
    pass
