"""SitePersistence Module"""
from collections import namedtuple
from flask import current_app

from .config_persistence import export_config, import_config
from ..database import db
from ..models.app_text import AppText
from ..models.client import Client
from ..models.communication_request import CommunicationRequest
from ..models.coding import Coding
from ..models.intervention import Intervention
from ..models.intervention_strategies import AccessStrategy
from ..models.notification import Notification
from ..models.organization import Organization
from ..models.questionnaire import Questionnaire
from ..models.questionnaire_bank import QuestionnaireBank
from ..models.research_protocol import ResearchProtocol
from ..models.role import Role, ROLE
from ..models.scheduled_job import ScheduledJob
from ..models.user import User, UserRoles
from .model_persistence import ExclusionPersistence, ModelPersistence


# NB - order MATTERS, as any type depending on another must find
# the dependent bits in place on import, such as the known:
#   ResearchProtocols before Orgs (Orgs point to RPs)
#   Coding before Orgs (Orgs reference language codings)
#   Orgs before all else
#   CommunicationRequest depends on QuestionnaireBanks

ModelDetails = namedtuple(
    'ModelDetails', ['cls', 'sequence_name', 'lookup_field'])
models = (
    ModelDetails(ResearchProtocol, 'research_protocols_id_seq', 'name'),
    ModelDetails(Coding, 'codings_id_seq', ('system', 'code')),
    ModelDetails(Organization, 'organizations_id_seq', 'id'),
    ModelDetails(Questionnaire, 'questionnaires_id_seq', 'identifier'),
    ModelDetails(QuestionnaireBank, 'questionnaire_banks_id_seq', 'name'),
    ModelDetails(Intervention, 'interventions_id_seq', 'name'),
    ModelDetails(AccessStrategy, 'access_strategies_id_seq', 'id'),
    ModelDetails(CommunicationRequest, 'communication_requests_id_seq',
                 'identifier'),
    ModelDetails(AppText, 'apptext_id_seq', 'name'),
    ModelDetails(Notification, 'notifications_id_seq', 'name'),
    ModelDetails(ScheduledJob, 'scheduled_jobs_id_seq', 'name'))


# StagingExclusions capture details exclusive of a full db overwrite
# that are to be restored *after* db migraion.  For example, when
# bringing the production db to staging, retain the staging
# config for interventions and service users

def client_users_filter():
    """Return query restricted to service users and those with client FKs"""
    return (
        User.query.join(Client).union(User.query.join(UserRoles).join(
            Role).filter(Role.name == ROLE.SERVICE)))


StagingExclusions = namedtuple(
    'StagingExclusions', ['cls', 'lookup_field', 'attributes', 'filter_query'])
staging_exclusions = (
    StagingExclusions(Client, 'client_id', [
        'client_id', 'client_secret', '_redirect_uris', 'callback_url'], None),
    StagingExclusions(Intervention, 'name', ['link_url'], None),
    StagingExclusions(User, 'id', ['telecom'], client_users_filter)
)


class SitePersistence(object):
    """Manage import and export of dynamic site data"""

    VERSION = '0.1'

    def __init__(self, target_dir):
        """Initialize SitePersistence instance

        :param target_dir: assign filesystem path to use non-default

        """
        self.dir = target_dir

    def export(self, staging_exclusion=False):
        """Generate JSON files defining dynamic site objects

        :param staging_exclusion: set only if persisting exclusions to retain
          on staging when pulling over production data

        Export dynamic data, such as Organizations and Access Strategies for
        import into other sites.  This does NOT export values expected
        to live in the site config file or the static set generated by the seed
        managment command.

        To import the data, use the seed command as defined in manage.py
        """

        def default_export():
            # The following model classes write to independent files
            for model in models:
                model_persistence = ModelPersistence(
                    model.cls, lookup_field=model.lookup_field,
                    target_dir=self.dir)
                model_persistence.export()

            # Add site.cfg
            export_config(target_dir=self.dir)

        def exclusive_export():
            for model in staging_exclusions:
                ep = ExclusionPersistence(
                    model_class=model.cls, lookup_field=model.lookup_field,
                    attributes=model.attributes,
                    filter_query=model.filter_query, target_dir=self.dir)
                ep.export()

        if staging_exclusion:
            exclusive_export()
        else:
            default_export()

    def import_(self, keep_unmentioned):
        """If persistence file is found, import the data

        :param keep_unmentioned: if True, unmentioned data, such as
            an organization or intervention in the current database
            but not in the persistence file, will be left in place.
            if False, any unmentioned data will be purged as part of
            the import process.

        """
        for model in models:
            model_persistence = ModelPersistence(
                model.cls, lookup_field=model.lookup_field,
                sequence_name=model.sequence_name,
                target_dir=self.dir)
            model_persistence.import_(keep_unmentioned=True)


        # Config isn't a model - separate function
        import_config(target_dir=self.dir)

        db.session.commit()
        current_app.logger.info("SitePersistence import complete")
